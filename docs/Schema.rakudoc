=begin pod

=head1 DESCRIPTION

Guide how to compose database Schema.

For people who want to write Schema auto-discovery plugins for various database technologies.

For cases when auto-discovery failed and Schema must be manually tuned
(like in MySQL where partitioning does not allow to create proper foreign keys relations).

=head1 NOTICE

It is NOT meant to be user-friendly ORM.
Limited interface is specifically designed to define and analyze database layout for further data extraction.

=head1 SYNOPSIS

Load required modules:

    use UpRooted::Schema;
    use UpRooted::Table;
    use UpRooted::Column;
    use UpRooted::Relation;

Define Schema:

    my $library = UpRooted::Schema.new( name => 'library' );

Add Tables to Schema:

    UpRooted::Table.new( :$schema, name => 'authors' );
    UpRooted::Table.new( :$schema, name => 'books' );

Add Columns to Tables:

    with $library.table( 'authors' ) -> $table {
        UpRooted::Column.new( :$table, name => 'id', type => 'bigint', :!is-nullable );
        UpRooted::Column.new( :$table, name => 'first_name', :is-nullable );
        UpRooted::Column.new( :$table, name => 'last_name', :!is-nullable );
    }

    with $library.table( 'books' ) -> $table {
        UpRooted::Column.new( :$table, name => 'id', type => 'bigint', :!is-nullable );
        UpRooted::Column.new( :$table, name => 'author_id', type => 'bigint', :!is-nullable );
        UpRooted::Column.new( :$table, name => 'title', :is-nullable );
    }

Connect Tables with Relations:

    UpRooted::Relation.new(
        name => 'who-wrote-what',
        parent-columns => $library.table( 'authors' ).columns( 'id' ),
        child-columns => $library.table( 'books' ).columns( 'author_id' )
    );


=head1 RULES

Bottom-up composition logic is used.
For example you do not tell Schema that it has some Table
but instead you define Table that claims to be in Schema.
This makes it easier to bulk-load data from denormalized C<information_schema>s in various databases.

Top-down breacrumb trails like C<$schema.table( 'x' ).column( 'y' )> will become automatically available
and you can use them during further composition.

Never add to Schema any virtual objects, such as views or materialized columns.

Composition will die on slightest sign of inconsistency, for example requesting unknown Column name from Table.

=head1 ADVANCED

=head2 Multi Column Relations

Just select multiple Columns from the same Table when defining Relation.

    UpRooted::Relation.new(
        name => 'compatibility',
        parent-columns => $library.table( 'cars' ).columns( 'model', 'year' ),
        child-columns => $library.table( 'parts' ).columns( 'car_model', 'car_year' )
    );

Arity must be the same.

=head2 Cross Schema Relations

Just define two Schemas, Tables and Columns in them.
Then connect Tables from different Schemas using Relations.

=head2 Differences between Schema and Tree

Schema represents entities in your database and relations between them.

Tree is subset of Schema with one Table being root.
You can derive many Trees from single Schema, depending which root Table is used.

Tree knows how and in which order reach data in all child Tables.

=head2 Caching

Once Schema is composed it can be reused for deriving multiple Trees.
Once Tree is derived it can be reused for reading data
for different Columns conditions in root Table.
